{"name":"Lazyopt","tagline":"the lazy coder's python option parser","body":"# lazyopt\r\n\r\n  `pip install lazyopt`\r\n\r\n## the lazy coder's option parser\r\n\r\n  most python scripts accumuluate a bunch of constants. eventually you might like to be able to set values for some of those constants with the command line. you could spend FOREVER writing an argument parser with [argparse](http://docs.python.org/2.7/library/argparse.html) like this:\r\n\r\n    # main.py\r\n    import argparse\r\n\r\n    IT_WAS_A_CONST = 5\r\n    BUT_NOW_I_WANNA_CHANGE_IT = \"damn\"\r\n    UGH_I_HATE_THIS = True\r\n\r\n    def main():\r\n\r\n      parser = argparse.ArgumentParser(description=\"some stupid script\")\r\n      parser.add_argument(\"--it-was-a-const\", default=5,\r\n                         dest='was_const')\r\n      parser.add_argument(\"--but-now-i-wanna-change-it\", default=\"damn\",\r\n                          dest='now_change')\r\n      parser.add_argument(\"--ugh-i-hate-this\", default=True,\r\n                          dest='hate')\r\n\r\n      args = parser.parse_args()\r\n      IT_WAS_A_CONST = args.was_const\r\n      BUT_NOW_I_WANNA_CHANGE_IT = args.now_change\r\n      UGH_I_HATE_THIS = args.hate\r\n\r\n      # FINALLY \r\n      do_what_you_came_for() \r\n\r\n    if __name__ == \"__main__\" : main() \r\n\r\njust so you can run\r\n\r\n    python main.py --but-now-i-wanna-change-it 22    \r\n\r\n\r\nwith `lazyopt`, you can just do this!\r\n\r\n    # main.py\r\n    import lazyopt\r\n\r\n    IT_WAS_A_CONST = 5\r\n    BUT_NOW_I_WANNA_CHANGE_IT = \"damn\"\r\n    UGH_I_HATE_THIS = True\r\n\r\n    def main():\r\n\r\n      lazyopt.apply_all() \r\n      do_what_you_came_for()\r\n\r\n    if __name__ == \"__main__\" : main()\r\n\r\nand you can still run\r\n\r\n    python  main.py --BUT-NOW-I-WANNA-CHANGE-IT 22\r\n\r\n\r\n\r\n## how\r\n\r\n`lazyopt` will parse any command in arguments like this:\r\n\r\n    --module_name.sub_module.var-name value-here\r\n\r\nand apply `value-here` to the variable `var_name` in the module `module_name.sub-module`. if no such variable exists, you'll get a nice `ConfigurationError` to let you know.  note that `lazyopt` converts dashes to underscores for you. \r\n\r\nif you do not specify `module_name` , `lazyopt` will '`value-here` to `var_name` in the module you use to call `apply_all`. most of the time this will be the main script you execute.\r\n\r\nargument values are typecast where appropriate: \"False\", \"True\" , and \"None\" take on their keyword cousins. numbers are integers unless a decimal is present; everything else is a string.\r\n\r\nif you pass arguments without values, like so:\r\n\r\n  --a-flag  --another-flag\r\n\r\nthose argument names will be assigned the value 'True'\r\n\r\nnote that `lazyopt` does not currently provide documentation or enforce any rules. it's lazy like that.\r\n\r\n## warning\r\n\r\n`lazyopt` is best for adding command line configuration to constants in a single script. it can work in more complicated situations, but you'll want to call `lazyopt.apply_all` in the python file you execute from the command line.\r\n\r\n\r\n## future plans\r\n* allow for capitalization correction where possible\r\n* add option to create actual arg parser\r\n* use comments as docs, default values for type checking\r\n* keep on keepin' on\r\n\r\n\r\n## why?\r\n\r\nlaziness\r\n\r\n## who?\r\n\r\nmark neyer, gentleman coder\r\n\r\nbsd\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}